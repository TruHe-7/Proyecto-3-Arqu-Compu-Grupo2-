CARG_TAM: MOV ACC, CTE				#SE CARGA EN EL ACC LA DIRECCION DE LA COSNT TAM
		  TAM
		  MOV DPTR,ACC
		  MOV ACC,[DPTR]			#MUEVE EL VALOR DEL TAM A LA ACC
TAM_NEG:  INV ACC					#INVIERTO LOS BITS DEL TAM
		  MOV A,ACC				#GUARDO EL VALOR DEL TAM INVERTIDO A LA AUX
		  MOV ACC, CTE
		  0X01						#CARGO UN 1 AL ACC
		  ADD ACC, A 				#SUMO EL TAM INVERTIDO CON UN UNO (COMPLEMENTO A2)
		  MOV A, ACC				#GUARDO EL A2 DEL TAM EN EL AUX
CARG_IT:  MOV ACC,CTE
		  IT						#CARGO DIRECCION DEL IT AL ACC
		  MOV DPTR, ACC
		  MOV ACC,[DPTR]			#CARGO EL VALOR DEL IT AL ACC
		  ADD ACC, A				#SUMO EL COMP A2 DEL TAM CON EL IT Y SE GUARDA EN EL ACC
LOOPTST:  JN						#SI EL IT+(-TAM)<0, ES QUE EL IT ES MENOR QUE EL TAM
		  ALGRM_BOOTH				#SE VA A LA FUNCION DEL ALGORITMO DE BOOTH
		  JMP						#SI IT +(-TAM)>0, ITERADOR ES MAS GRANDE 
		  END_LOOP					#SI OCURRE, EL CICLO TERMINA
ALGRM_BOOTH: MOV ACC, CTE
		  Q-1
		  MOV DPTR, ACC				 
		  MOV ACC, [DPTR]			#MUEVE Q A EL ACC
		  MOV A, ACC				#MUEVO Q-1 AL AUX
		  MOV ACC, CTE
		  0X01						#CARGO UN 1 AL ACC
		  AND ACC, A				#HAGO UN AND ENTRE Q-1 Y 1 PARA EXTRAER EL BIT LSB DE Q-1=Q-1(0)
		  MOV [DPTR],ACC			#GUARDO Q-1(0) EN Q-1
		  MOV ACC, CTE      		#CARGO EN EL ACC LA DIRECCION DE Q
		  Q
		  MOV DPTR, ACC				 
		  MOV ACC, [DPTR]			#MUEVE Q A EL ACC
		  MOV A, ACC				#MUEVO Q AL AUX
		  MOV ACC, CTE
		  0X01						#CARGO UN 1 AL ACC
		  AND ACC, A				#HAGO UN AND ENTRE Q Y 1 PARA EXTRAER EL BIT LSB DE Q
		  MOV A, ACC				#GUARDO EL VALOR DE EL BIT MENOS SIGNIFICANTE DE Q EN LA AUX
		  MOV ACC,CTE
		  Q-1
		  MOV DPTR, ACC
		  MOV ACC,[DPTR]
		  XOR ACC, A			    #GUARDA EN EL ACC EL XOR ENTRE EL Q0 Y Q-1
		  JZ  						#SI EL RESULTADO DEL XOR ES 0 SIGNIFICA QUE SON IGUALES
		  DESPLAZAMIENTO			#SE VA A LA FUNCION DESPLAZAMIENTO
		  JMP 						#SI EL RESULTADO DEL XOR DA 1 ES QUE SON DIFERENTES
		  DISTINCT					#SE VA A LA FUNCION DISTINCT
DISTINCT: MOV ACC, CTE      		#CARGO EN EL ACC LA DIRECCION DE Q
		  Q
		  MOV DPTR, ACC				 
		  MOV ACC, [DPTR]			#MUEVE Q A EL ACC
		  MOV A, ACC				#MUEVO Q AL AUX
		  MOV ACC, CTE
		  0X01						#CARGO UN 1 AL ACC
		  AND ACC, A				#HAGO UN AND ENTRE Q Y 1 PARA EXTRAER EL BIT LSB DE Q
		  JZ						#SI EL ACC=0 ES QUE Q0=0 Y Q-1=1
		  DISTINCT01				#SE DIRIGE A LA FUNCION CUANDO LOS NUMEROS SON 01
		  JMP						#SI ACC=1 ES QUE Q0=1Y Q-1=0
		  DISTINCT10				#SE DIRIGE A LA FUNCION CUANDO LOS NUMEROS SON 10
DESPLAZAMIENTO: MOV ACC, CTE      		#CARGO EN EL ACC LA DIRECCION DE Q
		  Q
		  MOV DPTR, ACC				 
		  MOV ACC, [DPTR]			#MUEVE Q A EL ACC
		  MOV A, ACC				#MUEVO Q AL AUX
		  MOV ACC, CTE
		  0X01						#CARGO UN 1 AL ACC
		  AND ACC, A				#HAGO UN AND ENTRE Q Y 1 PARA EXTRAER EL BIT LSB DE Q
		  MOV A, ACC				#GUARDO EL VALOR DE EL BIT MENOS SIGNIFICANTE DE Q EN LA AUX
		  MOV ACC, CTE
		  Q-1 						#SE GUARDA LA DIRECCION DE Q-1
		  MOV DPTR, ACC
		  MOV ACC, A
		  MOV [DPTR], ACC		    #SE GUARDA EN LA CASILLA DE Q-1, EL VALOR DE Q0		
		  MOV ACC, CTE				#SE CARGA EN LA ACC LA DIRECCION DE Q
		  Q
		  MOV DPTR, ACC
		  MOV ACC, [DPTR]			#SE MUEVE EL VALOR DE Q AL ACC
		  SHIFTLR ACC				#SHIFT LOGICO A LA DERECHA
		  MOV [DPTR], ACC			#METO Q ACTUALIZADO SIN TENER LSB DE A EN CASILLA DE Q
		  MOV ACC, CTE      		#CARGO EN EL ACC LA DIRECCION DE A
		  A
		  MOV DPTR, ACC				 
		  MOV ACC, [DPTR]			#MUEVE A, A EL ACC
		  MOV A, ACC				#MUEVO A AL AUX
		  MOV ACC, CTE
		  0X01						#CARGO UN 1 AL ACC
		  AND ACC, A				#HAGO UN AND ENTRE A Y 1 PARA EXTRAER EL BIT LSB DE A
		  MOV A, ACC				#CARGO EN AUX EL BIT LSB DE A
		  MOV ACC, CTE 				
		  Q
		  MOV DPTR, ACC
		  MOV ACC,[DPTR]			#CARGO EN ACC Q SHIFTEADO SIN TENER EL LSB DE A
		  ADD ACC, A 	#OR ACC,A			#PONGO EL BIT LSB DE A EN Q SHIFTEADO
		  MOV [DPTR], ACC			#GUARDO Q ACTUALIZADO EN SU CASILLA
		  MOV ACC, CTE
		  A
		  MOV DPTR, ACC				 
		  MOV ACC, [DPTR]			#MUEVE A A EL ACC
		  MOV A, ACC				#MUEVO A AL AUX
		  MOV ACC, CTE
		  0X08						#CARGO UN 8 AL ACC
		  AND ACC, A				#HAGO UN AND ENTRE A Y 8 PARA EXTRAER EL BIT MSB DE A
		  MOV A, ACC				#GUARDO EL VALOR DE EL BIT MAS SIGNIFICANTE DE A EN LA AUX
		  MOV ACC, CTE				
		  A 						#SE GUARDA LA DIRECCION DE A EN EL ACC
		  MOV DPTR, ACC
		  MOV ACC [DPTR]			#SE GUARDA EL VALOR DE A EN EL ACC
		  SHIFTLR ACC				#SHIFT LOGICO DE A
		  ADD ACC, A  #OR ACC,A				#PONGO EL MSB DE A ANTIGUO EN EL NUEVO A 
		  MOV [DPTR], ACC			# GUARDO EL A ACTUALIZADO EN LA CASILLA DE A
		  MOV ACC, CTE
		  IT
		  MOV DPTR,ACC
		  MOV ACC,[DPTR]			#ACC=IT
		  MOV A, ACC				#A=IT
		  MOV ACC,CTE
		  0x01
		  ADD ACC,A					#ACC=IT+1
		  MOV [DPTR],ACC			#ACTUALIZO EL VALOR DE IT
		  CARG_TAM
DISTINCT01: MOV ACC, CTE
		  M							#SE GUARDA EN EL ACC LA DIRECCION DE M
		  MOV DPTR, ACC
		  MOV ACC, [DPTR]			#SE GUARDA EN EL ACC EL VALOR DE M
		  MOV A, ACC				#SE GUARDA EN AUX EL VALOR DE M
		  MOV ACC, CTE
		  A							#SE GUARDA EN EL ACC LA DIRECCION DE A
		  MOV DPTR, ACC
		  MOV ACC, [DPTR]			#SE GUARDA EN EL ACC EL VALOR DE A
		  ADD ACC, A				#SE SUMA A+M Y SE GUARDA EN EL ACC
		  MOV [DPTR],ACC			# GUARDO LA RESTA A+M EN LA CASILLA DE A
		  JMP
		  DESPLAZAMIENTO			#DESPUES DE HACER LA SUMA SE PASA A EL DESPLAZAMIENTO
DISTINCT10: MOV ACC, CTE
		M 						 	#SE GUARDA EN EL ACC LA DIRECCION DE M
		MOV DPTR, ACC
		MOV ACC, [DPTR]				#SE GUARDA EN EL ACC EL VALOR DE M
		INV ACC						#SE INVIERTE ACC
		MOV A, ACC				#SE GUARDA M INVERTIDO EN LA AUX
		MOV ACC, CTE
		0X01						#SE GUARDA 1 EN EL ACC
		ADD ACC, A				#SE SUMA 1 CON LOS BITS INVERTIDOS DE M
		MOV A, ACC				#SE GUARDA EL COMPLEMENTO A2 DE M
		MOV ACC, CTE
		A 							#SE GUARDA LA DIRECCION DE A EN EL ACC
		MOV DPTR, ACC
		MOV ACC,[DPTR]				#SE GUARDA EL VALOR DE A EN EL ACC
		ADD ACC, A				#SE HACE LA OPERACION DE A-MAS
		MOV [DPTR], ACC 		# GUARDO LA RESTA A-M EN LA CASILLA DE A
		DESPLAZAMIENTO			#DESPUES DE HACER ESTA RESTA SE PASA A EL DESPLAZAMIENTO
END_LOOP: MOV ACC, CTE
		A
		MOV DPTR, ACC
		MOV ACC,[DPTR]
		MOV A, ACC 				#LLevamos el valor de A al registo A (Resultado)
		MOV ACC, CTE
		Q
		MOV DPTR, ACC
		MOV ACC, [DPTR]
		# HALT 0b11111000
IT:       0X00	#ITERADOR= 0
TAM:	  0X08  #TAM DE EL MULTIPLICANDO
Q:		  0X01	#MULTIPLICADOR
Q-1:	  0X00	#BIT QUE ESTA A LA DERECHA DEL Q0 (VALOR INICIAL ES 0)
M:		  0XFF	#MULTIPLICANDO
A:		  0X00 	#A QUE SE UTILIZA EN EL ALGORITMO DE BOOTH